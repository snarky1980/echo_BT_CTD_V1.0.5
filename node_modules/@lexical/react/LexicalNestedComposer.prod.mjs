/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{CollaborationContext as e}from"@lexical/react/LexicalCollaborationContext";import{LexicalComposerContext as t,createLexicalComposerContext as o}from"@lexical/react/LexicalComposerContext";import{getTransformSetFromKlass as r,createSharedNodeState as n,getRegisteredNode as i}from"lexical";import{useRef as s,useContext as a,useMemo as l,useEffect as c}from"react";import{jsx as p}from"react/jsx-runtime";const d=()=>{},f=()=>{};function m({initialEditor:m,children:h,initialNodes:u,initialTheme:g,skipCollabChecks:x,skipEditableListener:_}){const v=s(!1),E=a(t);null==E&&function(e,...t){const o=new URL("https://lexical.dev/docs/error"),r=new URLSearchParams;r.append("code",e);for(const e of t)r.append("v",e);throw o.search=r.toString(),Error(`Minified Lexical error #${e}; visit ${o.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}(9);const[k,{getTheme:b}]=E,w=l(()=>{const e=g||b()||void 0,t=o(E,e);void 0!==e&&(m._config.theme=e),m._parentEditor=m._parentEditor||k;const s=m._createEditorArgs,a=s&&s.namespace;if(u){d(),a||(f(),m._config.namespace=k._config.namespace);for(let e of u){let t=null,o=null;if("function"!=typeof e){const r=e;e=r.replace,t=r.with,o=r.withKlass||null}const s=i(m,e.getType());m._nodes.set(e.getType(),{exportDOM:s?s.exportDOM:void 0,klass:e,replace:t,replaceWithKlass:o,sharedNodeState:n(e),transforms:r(e)})}}else if(s&&s.nodes)a||(f(),m._config.namespace=k._config.namespace);else{const e=m._nodes=new Map(k._nodes);a||(m._config.namespace=k._config.namespace);for(const[t,o]of e)m._nodes.set(t,{exportDOM:o.exportDOM,klass:o.klass,replace:o.replace,replaceWithKlass:o.replaceWithKlass,sharedNodeState:n(o.klass),transforms:r(o.klass)})}return[m,t]},[]),C=a(e),{isCollabActive:L,yjsDocMap:M}=C??{},y=x||v.current||M&&M.has(m.getKey());return c(()=>{y&&(v.current=!0)},[y]),c(()=>{if(!_){const e=e=>m.setEditable(e);return e(k.isEditable()),k.registerEditableListener(e)}},[m,k,_]),p(t.Provider,{value:w,children:!L||y?h:null})}export{m as LexicalNestedComposer};
